---
layout: post
title: mongodb
categories: 杂谈
tags: mongodb
author: nsf
---

* content
{:toc}

mongodb学习

```
完整内容请见https://www.runoob.com/mongodb/mongodb-replication.html
```



## 高级特性

```
详情请见原文
```

### 运算符

#### $占位符

[`$`](https://docs.mongodb.com/manual/reference/operator/update/positional/#up._S_)运算符标识要更新的数组中的元素，而无需显式指定数组中元素的位置

example:

```
students使用以下文档创建一个集合：
db.students.insert([
   { "_id" : 1, "grades" : [ 85, 80, 80 ] },
   { "_id" : 2, "grades" : [ 88, 90, 92 ] },
   { "_id" : 3, "grades" : [ 85, 100, 90 ] }
])
更新id=1的文档，将第一个匹配到grades里面分数为80的改为82：
db.students.updateOne(
   { _id: 1, grades: 80 },
   { $set: { "grades.$" : 82 } }
)
结果如下：
{ "_id" : 1, "grades" : [ 85, 82, 80 ] }
{ "_id" : 2, "grades" : [ 88, 90, 92 ] }
{ "_id" : 3, "grades" : [ 85, 100, 90 ] }
```

```
students集合中的文档，该文档的 grades元素值为嵌入式文档的数组：
{
  _id: 4,
  grades: [
     { grade: 80, mean: 75, std: 8 },
     { grade: 85, mean: 90, std: 5 },
     { grade: 85, mean: 85, std: 8 }
  ]
}
db.students.updateOne(
   { _id: 4, "grades.grade": 85 },
   { $set: { "grades.$.std" : 6 } }
)
将第一个匹配到的grade值为85的文档的std字段的值为6
结果如下：
{
   "_id" : 4,
   "grades" : [
      { "grade" : 80, "mean" : 75, "std" : 8 },
      { "grade" : 85, "mean" : 90, "std" : 6 },
      { "grade" : 85, "mean" : 85, "std" : 8 }
   ]
}
```

总结：位置$操作符充当更新文档查询中**第一个匹配的占位符**

#### $slice切片

example

```
db.posts.find( {}, { comments: { $slice: [ 20, 10 ] } } )
```

$slice: [ 20, 10 ]里面第一个参数为skip的元素数量 , 第二个参数是往后获取元素数量限制个数limit 。

在update操作里面也能用$slice切片来更新数据，主要是保留某个切片区间的数据。

#### db.eval()js操作

`db.eval`**(***function***,** *arguments***)**

example：

```
db.eval( function(name, incAmount) {
            var doc = db.getCollection('ai_data').findOne( { _id : ObjectId("5ec61f8db125a4733fa6e9dd") } );
            doc.data[0][2] = 1;
            db.getCollection('ai_data').save( doc );
            return doc;
         } );
```

这样可以实现所有能想到的复杂操作，缺点是从4.2版本起这个功能被移除了，可以选择使用load()方法载入js文件，然后可以直接调用js函数，用这种方式来实现运行js脚本。

### 多层次操作

#### 单collection多次document操作

**db.collection.bulkWrite()**

提供可控执行顺序的批量写操作，语法如下

```
db.collection.bulkWrite(
	[ , , ... ],
	{
		writeConcern : ,
		ordered : 
	}
)
```

| 参数             | 类型     | 描述                                                         |
| :--------------- | :------- | :----------------------------------------------------------- |
| **operations**   | array    | bulkWrite() 写操作的数组。支持操作：insertOne、updateOne、updateMany、deleteOne、deleteMany、replaceOne |
| **writeConcern** | document | 可选， [write concern](https://docs.mongodb.com/v4.0/reference/write-concern/) 文档，省略则使用默认的 write concern。 |
| **ordered**      | boolean  | 可选，表示mongod实例有序还是无序执行操作。默认值true。       |

MongoDB支持的WriteConncern选项如下

1. w: 数据写入到number个节点才向用客户端确认
   - {w: 0} 对客户端的写入不需要发送任何确认，适用于性能要求高，但不关注正确性的场景
   - {w: 1} 默认的writeConcern，数据写入到Primary就向客户端发送确认
   - {w: “majority”} 数据写入到副本集大多数成员后向客户端发送确认，适用于对数据安全性要求比较高的场景，该选项会降低写入性能
2. j: 写入操作的journal持久化后才向客户端确认
   - 默认为”{j: false}，如果要求Primary写入持久化了才向客户端确认，则指定该选项为true
3. wtimeout: 写入超时时间，仅w的值大于1时有效。
   - 当指定{w: }时，数据需要成功写入number个节点才算成功，如果写入过程中有节点故障，可能导致这个条件一直不能满足，从而一直不能向客户端发送确认结果，针对这种情况，客户端可设置wtimeout选项来指定超时时间，当写入过程持续超过该时间仍未结束，则认为写入失败。

example

```
db.collection.bulkWrite(
   [
      { insertOne : <document> },
      { updateOne : <document> },
      { updateMany : <document> },
      { replaceOne : <document> },
      { deleteOne : <document> },
      { deleteMany : <document> }
   ],
   { ordered : false }
)
```

缺点：只支持同一集合内操作

#### 事务

MongoDB 4.0 引入的事务功能，支持多文档ACID特性

#### python 版本

pymongo下测试通过(mongodb4.2)。

```
import pymongo
from bson import ObjectId

c1 = 'apple'
c2 = 'xigua'
task_client = pymongo.MongoClient(
    "mongodb://XXX:XXXXXX@127.0.0.1:27017/?authSource=admin&readPreference=primary"
    "&appname=MongoDB%20Compass&ssl=false&retryWrites=false")
with task_client.start_session() as s:
    s.start_transaction()
    task_db = task_client["furit"]
    task_db[c1].insert_one({'_id': ObjectId("5ecb5eaf2feaca47432224da")}, session=s)
    task_db[c1].delete_one({'_id': ObjectId("5ecb5eaf2feaca47432224da")}, session=s)
    task_db[c2].insert_one({'task_id': ObjectId("5ecb5eaf2feaca47432224da")}, session=s)
    task_db[c2].delete_many({'task_id': ObjectId("5ecb5eaf2feaca47432224da")}, session=s)
    s.commit_transaction()
```

`Session`是 MongoDB 3.6 版本引入的概念，引入这个特性主要就是为实现多文档事务。

注意：

- 事务必须用在副本集情景下否则会报错
- mongodb版本在4.0以上，4.0支持副本集（replica sets）4.2开始支持分片集群（sharded clusters）

mongodb单机转副本集用来测试对事务的支持，过程如下：

在配置文件mongo.cfg添加以下内容

```
replication:
  oplogSizeMB: 10240
  replSetName: apple

sharding:
  clusterRole: shardsvr
```

重启服务

mongodb命令行下输入以下命令：

```
use admin
cfg={"_id":"apple","members":[{"id":0,"host":"127.0.0.1:27017"}]}
rs.initiate(cfg)
```

